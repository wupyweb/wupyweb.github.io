[{"title":"python之多线程模块threading","url":"/2018/12/26/python之多线程模块threading/","content":"### 1，Thread Objects\n#### class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)\n一些参数：\n- target：代表调用的函数\n- args：函数的参数元组\n- kwargs：函数的参数字典\n#### start()\n启动一个线程\n#### run()\n线程的活动，run()方法调用target传来的函数\n#### join()\n等到线程终止\n\n### 2，Lock Objects\n#### acquire()\n锁的获取\n#### release()\n锁的释放\n### 3，RLock Objects\n RLock允许在同一线程中被多次acquire。\n\n```\nimport threading\nlock = threading.Lock()\n#Lock对象\nlock.acquire()\nlock.acquire()\n#产生了死琐。\nlock.release()\nlock.release()\n\nimport threading\nrLock = threading.RLock()\n#RLock对象\nrLock.acquire()\nrLock.acquire()\n#在同一线程内，程序不会堵塞。\nrLock.release()\nrLock.release()\n```\n### 4，Condition Objects\n可以把Condiftion理解为一把高级的琐，它提供了比Lock, RLock更高级的功能，允许我们能够控制复杂的线程同步问题。threadiong.Condition在内部维护一个琐对象（默认是RLock），可以在创建Condigtion对象的时候把琐对象作为参数传入。Condition也提供了acquire, release方法，其含义与琐的acquire, release方法一致，其实它只是简单的调用内部琐对象的对应的方法而已。Condition还提供wait方法、notify方法、notifyAll方法(特别要注意：这些方法只有在占用琐(acquire)之后才能调用，否则将会报RuntimeError异常。\n#### wait()\n线程挂起，直到收到一个notify通知或者超时（可选的，浮点数，单位是秒s）才会被唤醒继续运行。wait()必须在已获得Lock前提下才能调用，否则会触发RuntimeError。调用wait()会释放Lock，直至该线程被Notify()、NotifyAll()或者超时线程又重新获得Lock.\n#### notify()\n通知其他线程，那些挂起的线程接到这个通知之后会开始运行，默认是通知一个正等待该condition的线程,最多则唤醒n个等待的线程。notify()必须在已获得Lock前提下才能调用，否则会触发RuntimeError。notify()不会主动释放Lock。\n#### 捉迷藏游戏\n 现在写个捉迷藏的游戏来具体介绍threading.Condition的基本使用。假设这个游戏由两个人来玩，一个藏(Hider)，一个找(Seeker)。游戏的规则如下：1. 游戏开始之后，Seeker先把自己眼睛蒙上，蒙上眼睛后，就通知Hider；2. Hider接收通知后开始找地方将自己藏起来，藏好之后，再通知Seeker可以找了； 3. Seeker接收到通知之后，就开始找Hider。Hider和Seeker都是独立的个体，在程序中用两个独立的线程来表示，在游戏过程中，两者之间的行为有一定的时序关系，我们通过Condition来控制这种时序关系。\n\n```\n#!/usr/bin/python\n#coding: utf-8\n\nimport threading, time\n\ndef Seeker(cond, name):\n    time.sleep(2)\n    cond.acquire()\n    print('%s :我已经把眼睛蒙上了！'% name)\n    cond.notify()\n    cond.wait()\n    for i in range(3):\n        print('%s is finding!!!'% name)\n        time.sleep(2)\n    cond.notify()\n    cond.release()\n    print('%s :我赢了！'% name)\n\ndef Hider(cond, name):\n    cond.acquire()\n    cond.wait()\n    for i in range(2):\n        print('%s is hiding!!!'% name)\n        time.sleep(3)\n    print('%s :我已经藏好了，你快来找我吧！'% name)\n    cond.notify()\n    cond.wait()\n    cond.release()\n    print('%s :被你找到了，唉~^~!'% name)\n\n\nif __name__ == '__main__':\n    cond = threading.Condition()\n    seeker = threading.Thread(target=Seeker, args=(cond, 'seeker'))\n    hider = threading.Thread(target=Hider, args=(cond, 'hider'))\n    seeker.start()\n    hider.start()\n    seeker.join()\n    hider.join()\n\n```\n### 5，Event Objects\n#### is_set()\n当且仅当内部表示为True时返回True。如果set()没有设定，则说明为为False\n#### set()\n设定内部标志为True。所有线程等到它为真时，都会被唤醒。调用了wait()的线程，一旦检测到内部标志位True时，那么都不会继续阻塞了\n#### clear()\n设定内部标识为False。随后，调用wait()的线程都会被阻塞，直到调用set()将内部标志设置为True\n#### wait()\n阻塞线程，知道内部标志设置为True。如果内部标志在入口时为真，则立即返回。 否则，阻塞将持续到另一个线程调用set()将标志设置为true，或直到可选超时发生才会结束。此方法在退出时返回内部标志，因此除非给出超时且操作超时，否则它将始终返回True\n#### 生产者消费者\n\n```\n#!/usr/bin/pyhton\n#coding: utf-8\n\nimport threading\nimport time\nfrom random import randint\n\n\ndef customers(event, lists):\n    t = threading.current_thread()\n    while 1:\n        event.wait()\n        if event.is_set():\n            try:\n                i = lists.pop()\n                print('{0} is customed by {1}'.format(i, t.name))\n                event.clear()   #阻塞所有线程\n            except IndexError:\n                pass\n\n\ndef producer(event, lists):\n    t = threading.current_thread()\n    while 1:\n        i = randint(1, 30)\n        lists.append(i)\n        print('{0} is produced by {1}'.format(i, t.name))\n        event.set()     #唤醒其他线程\n        time.sleep(1)    #没有实际意义，为了结果输出时看的清楚点。\n\ndef main():\n    threads = []\n    lists = []\n    event = threading.Event()\n\n    for name in ('customer1', 'customer2'):\n        thread = threading.Thread(target=customers, args=(event, lists))\n        threads.append(thread)\n        thread.start()\n\n    produce_thread = threading.Thread(target=producer, args=(event, lists))\n    threads.append(produce_thread)\n    produce_thread.start()\n\n    for thread in threads:\n        thread.join()\n\nif __name__ == '__main__':\n    main()\n\n```\n### 参考文章\n[Python3入门之线程threading常用方法](https://www.cnblogs.com/chengd/articles/7770898.html)\n\n[threading模块](https://www.jianshu.com/p/653cfc4bda55)\n\n[官方文档](https://docs.python.org/3.6/library/threading.html)","tags":["python","threading"]},{"title":"github上部署hexo博客","url":"/2018/12/25/github上部署hexo博客/","content":"## 一，node.js和git的安装\n\n### 1, 新安装好git后，我们需要进行一下设置（必须）\n\n```\n#设置用户名和用户邮箱\ngit config --global user.name \"user_name\"\ngit config --global user.email \"email@example.com\"\n```\n### 2，创建SSH key\n\n```\nssh-keygen -t rsa –C “email@example.com”\n```\n创建过程中一路按回车即可，然后到保存秘钥的文件夹下，可以发现两个文件id_rsa和id_rsa.pub，分别为私钥和公钥。\n\n在github的个人账户的setting的选项中添加ssh key，复制公钥的内容到key。\n![image](http://img1.sycdn.imooc.com/59c1d7ef0001c75411330860.png)\n### 3，node.js安装\n\n官网下载msi安装包，直接安装就好了\n## 二，hexo的安装\n```\nnpm install -g hexo-cli\n```\n初始化自己的博客\n\n```\nhexo init <blog_file_name>\n```\n运行看看自己的博客，访问http://localhost:4000/\n\n```\ncd <blog_file_name>\nhexo server\n```\n## 三，把博客部署到github\n\n博客文件夹下有这么个文件，_config.yml，这个是博客的配置文件\n\n修改deploy的配置，注意type前面有两个空格，冒号后面有一个空格\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/wupyweb/wupyweb.github.io.git\n  branch: master\n```\n部署到github，依次运行下面两个命令\n```\nhexo g\nhexo d\n```\n不出意外的话，这样就部署成功了\n## 四，更换主题\n[hexo主题官网](https://hexo.io/themes/)\n\n上面这个网站有很多主题供下载，下载好后替换themes中默认主题，然后在_config.yml中修改为自己下载的主题\n\n```\ntheme: aircloud\n```\n## 五，新建文章\n\n```\nhexo new [layout] <title>\n```\n布局|\t路径\n---|---\npost|\tsource/_posts\npage|\tsource\ndraft|\tsource/_drafts\n在source文件夹下能看到我们新建的文章，为md格式的文件，语法为markdown","tags":["hexo"]}]